#!/bin/bash
# kernelupdate-tinker -- Joe Brendler 11 August 2023
# adapted from kernelupdate-dom0 of October 2021,
#   makeU-distrib-tar of February 2022, and
#   installU_onServer of February 2022
#
# Interactively issue the sequence of commands that accomplishes a kernel update for a tinkerboard
#
# this process assumes you have already cloned the kernel sources and built a kernel at least once --
# build cross compiler
# crossdev --clean --target armv7a-unknown-linux-gnueabihf
# crossdev --b ~2.40 --g ~12.3 --k ~2.37 --l ~6.1 --target armv7a-unknown-linux-gnueabihf
#-----[ retrieve kernel sources ]---------------------------------------
# git clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git
# cd linux
# git branch --list --remotes
# git branch --show-current
# git checkout linux-6.4.y
#-----[ Fetch Tinkerboard default kernel config ]------------------------
# curl -L https://raw.githubusercontent.com/TinkerBoard/debian_kernel/develop/arch/arm/configs/min>
#-----[ configure kernel ]-----------------------------------------------
# make ARCH=arm miniarm-rk3288_defconfig -j16
# make ARCH=arm menuconfig -j16
# cp .config /home/joe/MyTinkerboardFiles/.config-6.4.y-baseline
#
# see also instructions at "tinker04-NEW-kernel-custom-rebuild-commands"
#

source /usr/local/sbin/script_header_brendlefly

#---[ local variables ]-------------------------------------------------------
DEBUG="false"
#DEBUG="true"
VERBOSE=$TRUE
verbosity=3
BUILD="0.0.0a-20230801"

eval $( grep ^PORTDIR /etc/portage/make.conf )
eval $( grep ^PKGDIR /etc/portage/make.conf )
eval $( grep ^DISTDIR /etc/portage/make.conf )

build_root="/home/joe/MyTinkerboardFiles"
sources_dir="${build_root}/linux"
config_dir="${build_root}/kernelconfigs"
build_dir="${build_root}/build"
status_file="${build_dir}/status"
tinker_dir="${build_dir}/tinker"
tinker_config="${tinker_dir}/.config"
kernel_image_dir="${build_dir}/tinker_kernel_images"
kernel_basename="linux-rk3288-tinker-s_kernel_image"

# create the build directory structure if it does not exist (-p makes parents)
[[ ! -d "${tinker_dir}" ]] && mkdir -pv "${tinker_dir}"
[[ ! -d "${kernel_image_dir}" ]] && mkdir -pv "${kernel_image_dir}"

# create the staging directory structure if it does not exist
distrib_dir="${tinker_dir}/tmp/distrib"
kernel_distrib_dir="${distrib_dir}/boot"
lib_dir="${distrib_dir}/lib"
[[ ! -d "${distrib_dir}" ]] && mkdir -pv "${distrib_dir}"
[[ ! -d "${kernel_distrib_dir}" ]] && mkdir -pv "${kernel_distrib_dir}"
[[ ! -d "${lib_dir}" ]] && mkdir -pv "${lib_dir}"

# set up the cross-building make command
make_tinker="make O=${tinker_dir}/ ARCH=arm CROSS_COMPILE=armv7a-unknown-linux-gnueabihf- -j16"

old_dir=$PWD
message "Old pwd: ${old_dir}" && cd ${sources_dir} && message "Now working in $PWD"
version_number=$(${make_tinker} kernelversion)
d_message "version_number: ${version_number}" 2
myversion="${version_number}-gentoo"
kernel_image_name="${kernel_basename}-${version_number}"

devel_dir="/home/joe/myUtilities"
ebuild_dir="/home/joe/joetoo/sys-kernel/${kernel_basename}"
publish_cmd_file="${build_dir}/publish_${kernel_image_name}"
[[ ! -d "${ebuild_dir}" ]] && mkdir -pv "${ebuild_dir}"

command_sequence=(
'nodist_path && echo $PATH'
'cp -v ${tinker_config} ${config_dir}/.config.bak'
'${make_tinker} mrproper'
'cp -v ${config_dir}/.config.bak ${tinker_config}'
'${make_tinker} prepare'
'${make_tinker} oldconfig'
'${make_tinker} menuconfig'
'cp -v ${tinker_config} ${config_dir}/.config.${version_number}'
'${make_tinker} zImage'
'${make_tinker} modules'
'${make_tinker} rk3288-tinker-s.dtb'
'clean_distrib_dirs'
'install_kernel_and_dtb_file'
'install_modules'
'make_tarball'
'publish_source_and_ebuild_update'
)

#-----[ functions ]--------------------------------------------------
nodist_path() { export PATH=$(echo $PATH | sed 's|/usr/lib/distcc/bin:||' | sed 's|/usr/lib/ccache/bin:||'); }

new_prompt()        # set external variable $answer based on reponse to prompt $1
{ ps=$1; echo; echo; CUU; SCP; message_n "$ps [Yes/no/skip|Yns]: " && read answer; # '=~' not in busybox
while ! expr "${answer:0:1}" : [yYnNsS] >/dev/null;  # answer not a regex match
do RCP; echo -en "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$ps [Yes/no/skip|Yns]: " && read answer; done; }

#-----[ local functions ]-------------------------------------------------------

display_config()
{
d_message "${LBon}.........myversion=[${BWon}$myversion${LBon}]${Boff}" 1
d_message "${LBon}....version_number=[${BWon}$version_number${LBon}]${Boff}" 1
d_message "${LBon}........build_root=[${BWon}$build_root${LBon}]${Boff}" 1
d_message "${LBon}.......sources_dir=[${BWon}$sources_dir${LBon}]${Boff}" 1
d_message "${LBon}........config_dir=[${BWon}$config_dir${LBon}]${Boff}" 1
d_message "${LBon}.........build_dir=[${BWon}$build_dir${LBon}]${Boff}" 1
d_message "${LBon}........tinker_dir=[${BWon}$tinker_dir${LBon}]${Boff}" 1
d_message "${LBon}.......distrib_dir=[${BWon}$distrib_dir${LBon}]${Boff}" 1
d_message "${LBon}..kernel_image_dir=[${BWon}$kernel_image_dir${LBon}]${Boff}" 1
d_message "${LBon}kernel_distrib_dir=[${BWon}$kernel_distrib_dir${LBon}]${Boff}" 1
d_message "${LBon}...........lib_dir=[${BWon}$lib_dir${LBon}]${Boff}" 1
d_message "${LBon}...kernel_basename=[${BWon}$kernel_basename${LBon}]${Boff}" 1
d_message "${LBon}.kernel_image_name=[${BWon}$kernel_image_name${LBon}]${Boff}" 1
d_message "${LBon}.........devel_dir=[${BWon}$devel_dir${LBon}]${Boff}" 1
d_message "${LBon}........ebuild_dir=[${BWon}$ebuild_dir${LBon}]${Boff}" 1
d_message "${LBon}..     status_file=[${BWon}$status_file${LBon}]${Boff}" 1
d_message "${LBon}..publish_cmd_file=[${BWon}$publish_cmd_file${LBon}]${Boff}" 1
}

clean_distrib_dirs()
{
  ## remove regular files from *_distrib_dir and everything from lib_dir
  message "${LBon}Cleaning the distribution staging directory...${Boff}"
  for x in $distrib_dir $kernel_distrib_dir
  do
    [[ -d $x ]] && find $x -maxdepth 1 -type f -iname '*' -delete
  done
  [[ -d $lib_dir ]] && find $lib_dir -mindepth 1 -iname '*' -delete
  # clean the make and staging dirs
}

install_kernel_and_dtb_file()
{
  # stage kernel
  cd ${sources_dir} && message "Now working in $PWD"
  message "${LBon}Staging the kernel...${Boff}"
  cp -av ${tinker_dir}/arch/arm/boot/zImage ${kernel_distrib_dir}/
  message "${LBon}Staging the dtb file...${Boff}"
  cp -av ${tinker_dir}/arch/arm/boot/dts/rk3288-tinker-s.dtb ${kernel_distrib_dir}/
}

install_modules()
{
  # stage modules
  cd ${sources_dir} && message "Now working in $PWD"
  message "${LBon}Staging the modules...${Boff}"
  lnstall_cmd='${make_tinker} INSTALL_MOD_PATH="$distrib_dir" modules_install'
  eval $lnstall_cmd

  # fix the build symlink
  message "${LBon}Fixing the ${lib_dir}/modules/${version_number}/build symlink...${Boff}"
  link_command="ln -snf /usr/src/linux-${myversion} ${lib_dir}/modules/${version_number}/build"
  eval $link_command
  cd $old_dir && message "Now working in $PWD"
}

make_tarball()
{
  message "${BGon}Entering distrib_dir${Boff}"
  cd $distrib_dir
  d_message "pwd: $(pwd)" 2

  # create staged tar archive
  message "${LBon}Creating the tar archive...${Boff}"

  tar_command="tar \
    --exclude lib/modules/${myversion}/source/ \
    --exclude lib/firmware \
    -cvjf ${kernel_image_name}.tar.bz2 \
    boot lib"
  eval $tar_command && \
  message "${BYon}Complete.  Your tarball is located in the ${LBon}${distrib_dir}${BYon} directory${Boff}" || \
  E_message "${BRon}Something went wrong -- refer to output above${Boff}"
  cd $old_dir && message "Now working in $PWD"
}

publish_source_and_ebuild_update()
{
echo; message "copying package ${distrib_dir}/${kernel_image_name}.tar.bz2 to ${devel_dir}/"
cp -v ${distrib_dir}/${kernel_image_name}.tar.bz2 ${devel_dir}/
message "changing ownership for upload"
chown joe:joe ${devel_dir}/${kernel_image_name}.tar.bz2

echo; message "copying kernel [ ${kernel_image_name}-${version_number} ] files to server at [ ${kernel_image_dir} ]"
cp -v ${distrib_dir}/boot/* ${kernel_image_dir}/

echo; message "Updating symlink to kernel for tinker"

cd ${kernel_image_dir} && message "Now working in $PWD"
ln -snf zImage-${version_number}-gentoo zImage
cd ${old_dir} && message "Now working in $PWD"

message "Listing contents of ${kernel_image_dir}"
ls -al ${kernel_image_dir}/

echo; message "Building publish_cmd_file [ ${publish_cmd_file} ]..."
echo "cd ${devel_dir}/" > ${publish_cmd_file}
echo "echo new PWD: \${PWD}" >> ${publish_cmd_file}
echo "git pull" >> ${publish_cmd_file}
echo "git status" >> ${publish_cmd_file}
echo "git add ${kernel_image_name}.tar.bz2" >> ${publish_cmd_file}
echo "git commit -m \"adding ${kernel_image_name}\"" >> ${publish_cmd_file}
echo "git push origin master" >> ${publish_cmd_file}
echo  >> ${publish_cmd_file}
echo "cd ${ebuild_dir}/" >> ${publish_cmd_file}
echo "echo new PWD: \${PWD}" >> ${publish_cmd_file}
ebuild_list=()
#kernel_image_name="linux-${myversion}_rk3288-tinker-s_kernel_image"

for x in $(find ${ebuild_dir} -type f -iname "linux-*" | sort)
do
ebuild_list+=("${x}")
done
old_version=$(echo ${ebuild_list[$((${#ebuild_list[@]}-1))]} | sed "s|${ebuild_dir}/${kernel_basename}||" | sed 's|.ebuild||')
echo "old version: ${old_version}"
echo "new version: ${version_number}"

echo "cp ${ebuild_dir}/${kernel_basename}-${old_version}.ebuild ${ebuild_dir}/${kernel_image_name}.ebuild" >> ${publish_cmd_file}
echo "sed -i \"s|${old_version}|${version_number}|\" ${ebuild_dir}/${kernel_image_name}.ebuild" >> ${publish_cmd_file}
echo "rm ${ebuild_dir}/Manifest" >> ${publish_cmd_file}
echo "pkgdev manifest -f -d ${DISTDIR}" >> ${publish_cmd_file}
echo "git pull" >> ${publish_cmd_file}
echo "git status" >> ${publish_cmd_file}
echo "git add Manifest" >> ${publish_cmd_file}
echo "git add ../../metadata/md5-cache/sys-kernel/${kernel_image_name}" >> ${publish_cmd_file}
echo "git add ${kernel_image_name}.ebuild" >> ${publish_cmd_file}
echo "git commit -m \"adding ${kernel_image_name}\"" >> ${publish_cmd_file}
echo "git push origin master" >> ${publish_cmd_file}

cd ${old_dir}

separator "contents of ${publish_cmd_file} " $(hostname)
cat ${publish_cmd_file}
separator "running ${publish_cmd_file}" $(hostname)
chown joe:joe ${publish_cmd_file}
chmod +x ${publish_cmd_file}
sudo -u joe ${publish_cmd_file}
}

usage() {
  message "Usage: kernelupdate-tinker [-s|-r]"
  message "  -s | --status --> return status (next step, step_number)"
  message "  -r | --resume --> resume proccessing (with next step, step_number)"
  exit
}

#-----[ main script ]------------------------------------------------
checkroot
separator "kernelupdate-tinker-${BUILD}"
starting_step=0

[[ $# -gt 1 ]] && E_message "Invalid Arguments" && usage

[[ $# -eq 1 ]] && case $1 in
  "-s" | "--status" )
      read starting_step < ${status_file};
      message "${BWon}Status: Step $(($starting_step - 1)) complete; next step would be [ ${BMon}$starting_step${BWon} ] ( ${BGon}${command_sequence[starting_step]}${BWon} )${Boff}";
      exit;
      ;;
  "-r" | "--resume" )
      read starting_step < ${status_file};
      message "${BWon}Resuming at step [ ${BMon}$starting_step${BWon} ] ( ${BGon}${command_sequence[starting_step]}${BWon} )${Boff}";
      ;;
  *             )
      # default - error
      E_message "Error: bad argument [ $1 ]";
      usage;
      ;;
esac


display_config
sh_countdown 5

answer=""
if [[ $starting_step -eq 0 ]]
then
  do_first_prompt="${BMon}Remember, you must first run --\n${BGon}  cd ${sources_dir}\n  git branch --list --remotes\n  git checkout linux-<newversion>\n${Boff}"
  prompt "${do_first_prompt}${BMon}Did you already do that? ${Boff}?"
  [[ ! $answer == [Yy] ]] && exit
else
  do_first_prompt="${BMon}Resuming at step [ ${BWon}$starting_step${BMon} ] ( ${BGon}${command_sequence[starting_step]}${BMon} )${Boff}\n"
  do_first_prompt+="${BYon}Please verify configuration above.${Boff}"
  prompt "${do_first_prompt}\n${LBon} Continue? ${Boff}?"
  [[ ! $answer == [Yy] ]] && exit
fi

for ((step_number=${starting_step}; step_number<${#command_sequence[@]}; step_number++))
do
  d_message "Writing step_number [ $step_number ] to status_file ( $status_file )" 2
  echo $step_number > ${status_file}
  answer=""
  new_prompt "${BMon}Are you ready to run ${BGon}\"${command_sequence[step_number]}\"${BMon}?${Boff}"
  case $answer in
    [Yy] )  # execute this command and continue
      message "${LBon}About to run \"${BYon}${command_sequence[step_number]}${LBon}\"...${Boff}" ; \
      eval ${command_sequence[step_number]}; right_status $? ;;
    [Ss] ) ;; # skip this command and continue
    *    )  # abort due to negative answer
      message "${BRon}As instructed, not running ${BGon}\"${command_sequence[step_number]}\"${BRon}. Quitting...${Boff}" ; \
      exit ;;
  esac
done
final_msg="${BMon}zImage, modules, and dtb file for rk2388-tinker-s successfully staged in\n"
final_msg+="${build_dir}/tinker and published in ${kernel_image_name}.ebuild${Boff}"
message "${final_msg}"
